---
title: Observer Pattern의 정의
categories:
- design_pattern
layout: post
date: '2022-03-27 18:14:08'
---

### **정의**

>  옵저버 패턴에서는 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의합니다.

**클래스 다이어그램**

 ![observer]({{site.url}}/assets/img/observer.jpg){:class="img-responsive"} 
   [그림1 ]

```
옵저버 패턴에서 상태를 저장하고 지배하는 것은 주제 객체 입니다.
따라서 상태가 들어 있는 객체는 하나만 있을 수 있습니다.
옵저버는 여러 개가 있을 수 있으며, 주제 객체에서 상태가 바뀌었다는 것을 알려 주기를 기다리는, 주제에 의존적인 성질을 가지게 된다.
그러므로 하나의 주제와 여러 개의 옵저버가 연과된, 일대다 관계가 성립한다.
데이터 주인은 주제입니다.
옵저버는 데이터가 변경되었을 때 주제에서 갱신해 주기를 기다리는 입장이기 때문에 의존성을 가진다고 할 수 있습니다.
이런 방법을 사용하면 여러 객체에서 동일한 데이터를 제어하도록 하는 것에 비해 더 깔끔한 객체지향 디자인을 만들 수 있습니다.
```

**느슨한 결합의 위력**

* 두 객체가 느슨하게 결합되어 있다는 것은, 그 둘이 상호작용을 하긴 하지만 서로에 대해 잘 모른다는 것을 의미합니다.
* 옵저버 패턴에서는 주제와 옵저버가 느슨하게 결합되어 있는 객체 디자인을 제공합니다.

**주제가 옵저버에 대해서아는 것은 옵저버가 특정 인터페이스를 구현한다는 것 뿐입니다.**

옵저버의 Concrete Class가 무엇인지, 옵저버가 무엇을 하는지 등에 대해서는 알 필요가 없습니다.

**옵저버는 언제든지 새로 추가할 수 있습니다.**

주제는 옵저버 이터페이스를 구현하는 객체의 목록에만 의존하기 때문에 언제든지 새로운 옵저버를 추가할 수 있다.
실행 중에 한 옵저버를 다른 옵저버로 바뀌도 되고, 그렇게 해도 주제 객체는 계속해서 데이터를 보낼 수 있다.
마찬가지로 옵저버를 아무 때나 제거해도 된다. 

**새로운 형식의 옵저버를 추가하려고 할 때도 주제를 전혀 변경할 필요가 없다.**

옵저버가 되어야 하는 새로운 구상 클래스가 생겼다고 가정해 보자.
이 때도 새로운 클래스 형식을 닫아 들일 수 있도록 제제를 바꿔야 할 필요는 없다.
새로운 클래스에서 Observer 인터페이스를 구현하고 옵저버로 등록하기만 하면 된다.
주제 객체는 전혀 신경도 쓰지 않는다.
	
**주제와 옵저버는 서로 독립적으로 재 사용할 수 있다.**

주제나 옵저버를 다른 용도로 활용할 일이 있다고 해도 손쉽게 재 사용할 수 있다.
그 둘이 서로 단단하게 결합되어 있지 않기 때문이다.

**주제나 옵저버가 바뀌더라도 서로한테 영향을 미치지 않는다.**

둘이 서로 느슨하게 결합되어 있기 때문에 주제 혹은 옵저버 인터페이스를 구현한다는 조검난 만족된다면 어떻게 바꿔도 문제가 되지 않는다.

### **디자인 원칙**

> 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.
