---
title: 개방 폐쇄 원칙 (OCP)
layout: post
date: '2022-03-19 12:21:00'
categories:
- design_pattern
---

> 소프트웨어 개체(클래스, 모듈, 함수)는 확장에 열려 있어야하고, 수정에 닫혀 있어야 한다.

OCP가 잘 적용된다면, 이미 제대로 동작하는 원래 코드를 변경하는 것이 아니라 새로운 코드를 덧붙임으로써 나중에 그런 변경을 할 수 있게 된다.

**해결책은 추상화다**

모듈은 추상화를 조작할 수 있다.
이런 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있다.
그 모듈의 행위는 추상화의 새 파생 클래스들을 만듦으로써 확장이 가능하다.

1. OCP를 따르지 않는 예제

| ![OCP 위배]({{site.url}}/assets/img/OCP1.jpg){:class="img-responsive"} |
|:--:|
| 그림1 |

2. OCP를 따르는 예제

| ![OCP 준수]({{site.url}}/assets/img/OCP2.jpg){:class="img-responsive"} |
|:--:|
| 그림2. 스트레티지 패턴, Client는 개방 폐쇄 원칙을 따른다  |

AbstractServer가 아닌 ClientInterface로 이름을 지은 이유: <br>
*추상 클래스는 자신을 구현하는 클래스 보다도 클라이언트에 더 밀접하게 관련되어 있기 때문이다.*

| ![OCP 준수]({{site.url}}/assets/img/OCP3.jpg){:class="img-responsive"} |
|:--:|
| 그림3. 탬플릿 메소드 패턴, 기반 크래스는 개방 폐쇄 원칙을 따른다  |

그림3은 대안이 되는 구조를 보여 준다.
Policy 클래스는 어떤 종류의 정책을 구현하는 구체적인 공용 함수들을 갖는데,
그림2에서 본 client의 함수 들과 비슷한 것이다.
이 정책 함수들은 어떤 추상 인터페이스의 형식을 통해 작업하려는 일을 설명한다.
그러나 이번에는 추상 인터페이스가 Policy클래스 자체의 한 부분이다.
자바의 경우 추상 메소드일 것이다.
이런 함수들은 Policy 서브 타입에서 구현된다.
따라서 Policy 내부에 명시된 행위는 Policy클래스의 새로운 파생클래스를 생성함으로써 확장되거나 수정될 수 있다.
